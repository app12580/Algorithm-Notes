### description    
  (This problem is the same as Minimize Malware Spread, with the differences bolded.)  
    
  In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.  
    
  Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.  
    
  Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.  
    
  We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.  
    
     
    
  Example 1:  
    
  Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]  
  Output: 0  
  Example 2:  
    
  Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]  
  Output: 1  
  Example 3:  
    
  Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]  
  Output: 1  
     
    
  Note:  
    
  1 < graph.length = graph[0].length <= 300  
  0 <= graph[i][j] == graph[j][i] <= 1  
  graph[i][i] = 1  
  1 <= initial.length < graph.length  
  0 <= initial[i] < graph.length  
### solution    
```    
// 方法一： 并查集+ 暴力法  
// 效率比想象中的要高很多  
  
Runtime: 29 ms, faster than 57.60% of Java online submissions for Minimize Malware Spread II.  
Memory Usage: 65.6 MB, less than 50.00% of Java online submissions for Minimize Malware Spread II.  
  
  class Solution {  
      int[] parent;  
        
      public int minMalwareSpread(int[][] graph, int[] initial) {  
          int N = graph.length;  
          parent = new int[N];  
          Arrays.fill(parent, -1);  
          Arrays.sort(initial);   // sort the initial list to get the min index of result in case of a tie  
          Set<Integer> set = new HashSet<>();  
          for (int n : initial) set.add(n);  
            
          // build the union find set disabling the init elements  
          for (int i = 0; i < N; i++) {  
              if (set.contains(i)) continue;       
              for (int j = 0; j < N; j++) { //可以优化成j+1  
                  if (set.contains(j)) continue;  
                  if (graph[i][j] == 1) {  
                      union(i, j);  
                  }  
              }  
          }  
            
          int total = Integer.MAX_VALUE;  
          int res = -1;  
          for (int skip = 0; skip < initial.length; skip++) {  
              Map<Integer, Integer> cnts = new HashMap<>();  
              for (int mal = 0; mal < initial.length; mal++) {  
                  if (mal == skip) continue;  
                    
                  int malId = initial[mal];  
                  for (int i = 0; i < N; i++) {  
                      if (i == initial[skip]) continue;  
                        
                      if (graph[malId][i] == 1) {  
                          int root = find(i);  
                          cnts.putIfAbsent(root, -parent[root]);  
                      }  
                        
                  }  
                    
              }  
                
              int sum = 0;  
              for (int v : cnts.values()) {  
                  sum += v;  
              }  
                
              // if removing initial[skip] causes less spread  
              if (sum < total) {  
                  total = sum;  
                  res = initial[skip];  
                    
              }  
          }  
            
          return res;  
      }  
        
      private int find(int x) {  
          if (parent[x] < 0) return x;  
          parent[x] = find(parent[x]);  
          return parent[x];  
      }  
        
      // 这里为了节省一个size数组，使用parent里面的root节点来存储size， 而且还要配合fills(-1)  
      // 感觉没啥必要  
      private void union(int x, int y) {  
          x = find(x);  
          y = find(y);  
          if (x == y) return;  
          if (parent[x] <= parent[y]) { //parent向小的方向合并  
              parent[x] += parent[y];  
              parent[y] = x;  
          } else {  
              parent[y] += parent[x];  
              parent[x] = y;  
          }  
      }  
  }  
```    
    
### 个人解读    
  与[924](924_Minimize%20Malware%20Spread(Hard).md) 类似，只是多了一个不能再连接的特点。  
    
  区别在于，本题目相当于考察：在并查集中，如果断开一个节点，会脱落下来多少size的节点。  
    
  思路一：暴力法 + 并查集  
  将节点分成两类：initial里面的N(被感染的)，其他节点M，  
  1、将M点并查集一下  
  2、循环N，每次选择一个作为结果，然后遍历剩下的N-1个节点，对于N-1中的每个节点k：  
    获取所有与k相连的节点i，然后记录i所在并查集中的size。用一个map存储所有可能相连的并查集和其size  
  3、求和所有map中的size，越少越好。（代表剩下N-1个节点可能感染的size）  
    
    
tags:    
  -  并查集  
  -  暴力法  
