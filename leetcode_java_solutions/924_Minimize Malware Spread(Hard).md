### description    
  In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.  
    
  Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.  
    
  Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.  
    
  We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.  
    
  Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.  
    
     
    
  Example 1:  
    
  Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]  
  Output: 0  
  Example 2:  
    
  Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]  
  Output: 0  
  Example 3:  
    
  Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]  
  Output: 1  
     
    
  Note:  
    
  1 < graph.length = graph[0].length <= 300  
  0 <= graph[i][j] == graph[j][i] <= 1  
  graph[i][i] = 1  
  1 <= initial.length < graph.length  
  0 <= initial[i] < graph.length  
    
  又是不会说人话的一个题目：  
  翻译成人话：  
  1、环境中有若干节点，他们的联通情况用graph表示(怎么表示的略)  
  2、现在要经历两个步骤：A：对环境的若干个节点进行污染，污染哪些用initial表示  
  B：A阶段结束以后，接下来已经被污染的节点会向其他节点扩散  
    
  现在题目要求的东西是：  
  把A步骤中感染的节点去掉一个，使得最后(B阶段过后)感染的总体数量最少，如果这样方案有多个，返回索引最小的那个  
    
### solution    
```    
// 方法一： 并查集  
Runtime: 8 ms, faster than 72.22% of Java online submissions for Minimize Malware Spread.  
Memory Usage: 68.1 MB, less than 100.00% of Java online submissions for Minimize Malware Spread.  
  
  class Solution {  
        
      public int minMalwareSpread(int[][] graph, int[] initial) {  
          Arrays.sort(initial);  
          int len = graph.length;  
          DSU dsu = new DSU(len);  
          for(int i = 0; i < len; i++) {  
              for(int j = i + 1; j < len; j++) {  
                  if(graph[i][j] == 1) {  
                      dsu.union(i, j);  
                  }  
              }  
          }  
          int res = initial[0];  
          int size = Integer.MIN_VALUE;  
          Map<Integer, Integer> unionCount = new HashMap<>();  //每个集合访问了多少次  
          Map<Integer, Integer> unionIndex = new HashMap<>(); // 每个集合都有哪些节点在访问  
          for(int i: initial) {  
              int p = dsu.find(i);  
              unionCount.put(p, unionCount.getOrDefault(p, 0) + 1);  
              unionIndex.put(p, i);  
          }  
          for(Map.Entry<Integer, Integer> entry: unionCount.entrySet()) {  
              if(entry.getValue() == 1) {  
                  int p = entry.getKey();  
                  int index = unionIndex.get(p);  
                  if(dsu.sz[p] > size) {  
                      res = index;  
                      size = dsu.sz[p];  
                  } else if(dsu.sz[p] == size) {  
                      res = Math.min(index, res);  
                  }  
              }  
          }  
          return res;  
      }  
    
    
      class DSU {  
          int[] p, sz;  
    
          DSU(int N) {  
              p = new int[N];  
              for (int x = 0; x < N; ++x)  
                  p[x] = x;  
    
              sz = new int[N];  
              Arrays.fill(sz, 1);  
          }  
    
          public int find(int x) {  
              if (p[x] != x)  
                  p[x] = find(p[x]);  
              return p[x];  
          }  
    
          public void union(int x, int y) {  
              int xr = find(x);  
              int yr = find(y);  
              if (xr == yr) return;  
              p[xr] = yr;  
              sz[yr] += sz[xr];  
          }  
    
          public int size(int x) {  
              return sz[find(x)];  
          }  
      }  
        
        
  }  
     
```    
    
### 个人解读    
  主要难点在于节点之间可能是单行道，如果是相互的，那么用并查集可以轻松解决(先根据graph并查一下，然后再遍历initials，如果有某个并查集的count最大并且initial里面只有一个，那么就是它了；否则返回最小索引)  
    
  ```  
  0 <= graph[i][j] == graph[j][i] <= 1  
  ```  
  题目里有这条，开始没看见  
    
  总结： 思路没问题，大胆的往下写吧  
    
tags:    
  -  并查集  
