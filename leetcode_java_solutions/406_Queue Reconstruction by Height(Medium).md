### description  
假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。  
  
注意：  
总人数少于1100人。  
  
示例  
  
输入:  
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  
  
输出:  
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]  
### solution  
```  
class Solution {  
    public int[][] reconstructQueue(int[][] people) {  
       if (people == null || people.length == 0 || people[0].length == 0) {  
        return new int[0][0];  
         }  
        Arrays.sort(people, new Comparator<int[]>() {  
            @Override  
            public int compare(int[] o1, int[] o2) {  
                if(o1[0] != o2[0]) {  
                    return o2[0] - o1[0];  
                }  
                return o1[1] - o2[1];  
            }  
        });  
        List<int[]> list = new ArrayList<>();  
        for(int[] a: people) {  
            list.add(a[1], a);  
        }  
        return list.toArray(new int[list.size()][]);   
    }  
}  
```  
  
### 个人解读  
首先读题目时候第一时间没有明白题目什么意思，什么叫做"编写一个算法来重建这个队列"  
我第一时间的理解：  
输入:  
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  
输出:  
[[7,0], [4,0], [7,1], [5,2], [6,2], [5,5]]  
这才叫重建嘛。。。结果题目的意思是："编写一个算法来重新排序这个队列"  
  
特殊条件排序问题(解谜向排序)，每个位置的元素要根据前面几个的元素大小有关。  
由于本题目关乎多个元素间的**相对关系**，所以要去找元素的某项指标极值的情况(按某种规律排序)，或者直接相对排序，全部相对排序出来了，总体排序也就有了  
+ 相对排序：  
随便举个例子：拿到了[7,0]和[4,4]，能分清谁在前谁在后吗？分不清，所以pass掉。  
+ 极值排序：  
先找到极值：问题来了，是按照h排序呢？还是按照k排序呢？  
然后会某个瞬间意识到：低h的item不会影响高item的k值，所以就会按照h值从大到小排序，然后h相同时怎么办呢？  
因为相同h也会影响k值，所以如同h小的在前面一样，h相同则k小排在前面  
将例子中的排序后：  
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  
[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]  
然后尝试手动排序一下：  
[7,0]  
[7,0], [7,1]  
[7,0], [6,1], [7,1]  
[5,0], [7,0], [6,1], [7,1]  
[5,0], [7,0], [5,2], [6,1], [7,1]  
[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]  
与答案一致，而且手动操作时候很顺畅，接下来需要的就是找规律了  
然后发现，每次插入的元素的k值，恰好为下标  
  
  
  
  
  
tags:  
  - 数组  
  - 贪心算法？  
  - 数据结构  
