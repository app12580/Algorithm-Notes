### 写在最前  
  做到hard题目时候，发现很多题目关键都是在如何建立模型。所以感觉有必要总结一下，用科学的方法，记录一下DP都有哪些套路:  
  1、递进式DP：i表示前i个字符  
  2、拼接式DP："abcd" = "ab" + "cd"  
  3、零件式DP： 常见字符串处理中，在DP中存储着"aab","bbc"这样零碎字符串的结果(类似691)  
  4、DP顺序： 可以根据下标顺序，也可以从小到大 (例如那个接雨水的题目)  
  5、强行构建： 在很多题目中DP难以构建，需要在原有DP基础上，外挂一维信息，例如那个射气球的题目  

### 使用方法
DP有两种使用方式(从前往后和从后往前)： 从n开始，然后n-1，n-2一直到0。只有到最后才有明确返回值，之前一直都是递归调用。
从0开始，用数组或用单个变量来存储数据，然后从小到大使用（比较少见，主要因为从小到大时，方向性很难确定）。  

除了DP外，同样问题的可能解法： 贪婪算法啦，DFS啦，各种递归啦~不能吊死在DP一棵树上。    

### 指数扩展现象 
复杂度呈指数级别扩展现象。  
最常见的例子，求斐波那契数列时，直接return fn = fn-1 + fn-2  

### dp模型确立  
有时候不一定需要dp直接指向最终结果，反而可以是一些中间结果。(例如413. Arithmetic Slices (Medium)数组中等差递增子区间的个数)  
常见于需要区分情况的题目。这个时候，dp[]就需要以数组形式。  
  
两种定义方式：  
1、dp[i]: 第i个时候的最值，最后return dp[i]  
2、dp[i]: 以i为结尾时候的值，最后需要遍历dp[0]~dp[n]，然后return里面的最值  
  

### dp相关参数确立
有时候不光模型需要想心思，连参数也可能不是简单的n-1，n-2之类的。可能和平方数有关，可能和大小关系有关。在这种乱间隔dp的情况下，同一个位置的dp可能被计算多次。  

### 二维DP  
[例题](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md)  
最长公共子序列  
0-1 背包  

我理解的一维数组做法就是，从1遍历到n，每次扔进去一个，用来优化所有的dp  

### 状态转移方程  



### 常见题型  
-- 信件排错  
题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。  
  
定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：  
  
i==k，交换 i 和 k 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。  
i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。  
综上所述，错误装信数量方式数量为：  
dp[i] = (i-1) * dp[i-2] + (i-1)*dp[i-1]  
  
-- 母牛生产  
题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。  
  
"3 年之后" 这种话特别模糊  
第i年 小母猪A刚出生  
第i+1年 小母猪A   
第i+2年 小母猪A  
第i+3年 小母猪A 可以生了  
  
1， 2， 3, 4，6  
  
  
第 i 年成熟的牛的数量为：  
dp[i] = dp[i-1] + dp[i-3]  
  
// dp[i-3]为所有第i年新生母牛的数量
     
     
-- 背包问题
### 空间优化

在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，



因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，以防将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。

```

public int knapsack(int W, int N, int[] weights, int[] values) {
    int[] dp = new int[W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = W; j >= w; j--) {
           dp[j] = Math.max(dp[j], dp[j - w] + v);     //可以理解成优化： 对每一个物品进行优化，因为只能优化一次，所以j要从大的开始
        }
    }
    return dp[W];
    
    注意三个要点：
    1、dp[0]的初始化设置  
    2、内层循环的循环条件： j从最大容积开始，到当前项的体积w[i]为止。  
    3、状态转移方程： 目前见过三种了 
    dp[j] = dp[j] || dp[j-w]
    dp[j] = dp[j] + dp[j-w]     //统计时候用
    dp[j] = Math.max(dp[j], dp[j - w] + 1)      // 这种情况可以保证dp[m]是有内容的
    4、return的东西可能是dp中最后一个，也可能是整个数组中最大的那个值。

}     
 ```
 
   
### 背包问题的本质  
 背包问题的本质：以一维数组的方式，通过某种优化条件，将原本2^n的问题，转化成n^M的问题。  
     //2^n的意思是指每个n有或者没有，有2^n种情况  
     //n * M表示：外层循环是1~n遍历每一个元素，内层循环是M~0表示总价值从高的到低的。
     
### 双背包问题
  定义int[][]dp 即可，然后仍然按照特定顺序从大往小遍历，以优化的思想去遍历。      
     
     
### 完全背包问题
  好神奇诶~
  之前说过，内层循环从大往小遍历，是因为大的依赖于小的，从大往小遍历就能保证只优化一次。  
  所以说！！！内层循环从小到大遍历，也就可以优化无限多次，这！也就是完全背包的解决办法！  
  // 还是直接看代码舒服，能收获更多，不用去理解别人博客里说的云里雾里的东西。       

### 背包问题分类
  根据状态转移方程可以把背包问题分成三类：统计求和问题(dp不一定覆盖到)；最值问题(dp一定覆盖到)；是否可行问题。   
  根据内外层循环变量的不同可以分为：外层元素内层dp和外层dp内层元素循环，此时需要想好实际的"优化原理"确定方案。  
  

### 小技巧  
动态规划现在有个技巧，一维不够就想办法二维  
