### 使用方法
DP有两种使用方式： 从n开始，然后n-1，n-2一直到0。只有到最后才有明确返回值，之前一直都是递归调用。
从0开始，用数组或用单个变量来存储数据，然后从小到大使用（比较少见，主要因为从小到大时，方向性很难确定）。  

除了DP外，同样问题的可能解法： 贪婪算法啦，DFS啦，各种递归啦~不能吊死在DP一棵树上。    

### 指数扩展现象 
复杂度呈指数级别扩展现象。  
最常见的例子，求斐波那契数列时，直接return fn = fn-1 + fn-2  

### dp模型确立  
有时候不一定需要dp直接指向最终结果，反而可以是一些中间结果。(例如413. Arithmetic Slices (Medium)数组中等差递增子区间的个数)  
常见于需要区分情况的题目。这个时候，dp[]就需要以数组形式。  

### dp相关参数确立
有时候不光模型需要想心思，连参数也可能不是简单的n-1，n-2之类的。可能和平方数有关，可能和大小关系有关。在这种乱间隔dp的情况下，同一个位置的dp可能被计算多次。  

### 常见题型  
-- 信件排错  
题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。  
  
定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：  
  
i==k，交换 i 和 k 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。  
i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。  
综上所述，错误装信数量方式数量为：  
dp[i] = (i-1) * dp[i-2] + (i-1)*dp[i-1]  
  
-- 母牛生产  
题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。  
  
"3 年之后" 这种话特别模糊  
第i年 小母猪A刚出生  
第i+1年 小母猪A   
第i+2年 小母猪A  
第i+3年 小母猪A 可以生了  
  
1， 2， 3, 4，6  
  
  
第 i 年成熟的牛的数量为：  
dp[i] = dp[i-1] + dp[i-3]  
  
// dp[i-3]为所有第i年新生母牛的数量
     
     