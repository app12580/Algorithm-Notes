### 使用方法
DP有两种使用方式： 从n开始，然后n-1，n-2一直到0。只有到最后才有明确返回值，之前一直都是递归调用。
从0开始，用数组或用单个变量来存储数据，然后从小到大使用（比较少见，主要因为从小到大时，方向性很难确定）。  

除了DP外，同样问题的可能解法： 贪婪算法啦，DFS啦，各种递归啦~不能吊死在DP一棵树上。    

### 指数扩展现象 
复杂度呈指数级别扩展现象。  
最常见的例子，求斐波那契数列时，直接return fn = fn-1 + fn-2  

### dp模型确立  
有时候不一定需要dp直接指向最终结果，反而可以是一些中间结果。(例如413. Arithmetic Slices (Medium)数组中等差递增子区间的个数)  
常见于需要区分情况的题目。这个时候，dp[]就需要以数组形式。  

### dp相关参数确立
有时候不光模型需要想心思，连参数也可能不是简单的n-1，n-2之类的。可能和平方数有关，可能和大小关系有关。在这种乱间隔dp的情况下，同一个位置的dp可能被计算多次。  

### 二维DP  
[例题](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md)  
最长公共子序列  
0-1 背包  

我理解的一维数组做法就是，从1遍历到n，每次扔进去一个，用来优化所有的dp  

### 状态转移方程  



### 常见题型  
-- 信件排错  
题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。  
  
定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：  
  
i==k，交换 i 和 k 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。  
i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。  
综上所述，错误装信数量方式数量为：  
dp[i] = (i-1) * dp[i-2] + (i-1)*dp[i-1]  
  
-- 母牛生产  
题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。  
  
"3 年之后" 这种话特别模糊  
第i年 小母猪A刚出生  
第i+1年 小母猪A   
第i+2年 小母猪A  
第i+3年 小母猪A 可以生了  
  
1， 2， 3, 4，6  
  
  
第 i 年成熟的牛的数量为：  
dp[i] = dp[i-1] + dp[i-3]  
  
// dp[i-3]为所有第i年新生母牛的数量
     
     
-- 背包问题
### 空间优化

在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，



因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，以防将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。

```

public int knapsack(int W, int N, int[] weights, int[] values) {
    int[] dp = new int[W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = W; j >= 1; j--) {
            if (j >= w) {
                dp[j] = Math.max(dp[j], dp[j - w] + v);     //可以理解成优化： 对每一个物品进行优化，因为只能优化一次，所以j要从大的开始
            }
        }
    }
    return dp[W];
}     
 ```
 
   
 ### 背包问题的本质  
 背包问题的本质：以一维数组的方式，通过某种优化条件，将原本2^n的问题，转化成n^M的问题。  
     //2^n的意思是指每个n有或者没有，有2^n种情况  
     //n * M表示：外层循环是1~n遍历每一个元素，内层循环是M~0表示总价值从高的到低的。