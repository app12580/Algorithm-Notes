### 目录    
 1、 Morris Traversal (099)  莫里斯遍历   
 
 步骤：  
   
 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。  
   
 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点(指左子树下的最右边的节点)。  
   
 a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。  
   
 b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。  
   
 重复以上1、2直到当前节点为空。  
 写法一
 ```
    private void morrisIn(TreeNode head) {
         if (head == null) return;
         TreeNode cur = head;
         TreeNode next = null;
         while (cur != null) {
             next = cur.left;
             if (next != null) {
                 while (next.right != null && next.right != cur) next = next.right;
                 if (next.right == null) {
                     next.right = cur;
                     cur = cur.left;
                     continue;
                 } else {
                     next.right = null;
                 }
             }
             System.out.println(cur.val + " ");
             cur = cur.right;
         }
         System.out.println();
     }
 
 ```
 
 写法二：
 ```
 public void morrisTraversal(TreeNode root){
         TreeNode temp = null;
         while(root!=null){
             if(root.left!=null){
                 // connect threading for root
                 temp = root.left;
                 while(temp.right!=null && temp.right != root)
                     temp = temp.right;
                 // the threading already exists
                 if(temp.right!=null){
                     temp.right = null;
                     System.out.println(root.val);
                     root = root.right;
                 }else{
                     // construct the threading
                     temp.right = root;
                     root = root.left;
                 }
             }else{
                 System.out.println(root.val);
                 root = root.right;
             }
         }
     }
 
 ```
 
 2、 AC自动机
 https://blog.csdn.net/weixin_43923436/article/details/88635103   
 -- 很多博客根本不知道说人话   
 -- 需要知道几个重点概念：   
    首先：大量工作在于构建那个自动机上   
    ushers: 如果Trie里面有he/ she/ hers/ his这些，这样子当ushers开始遍历匹配时候，它会先看u，找不到，pass掉。然后会遇到she，会顺着she的Trie树往下走，之后就是重点了！！！！   
    当下一个字符r开始进来的时候，因为不存在hers的前缀，所以这个时候需要回溯，然而回溯到哪里呢？如果一般算法就是从头开始回溯了，但是AC自动机会告知从哪条路继续。  
    举例子： shers： 先走了she，之后给的是r走不通了， 这个时候怎么办？如果前面有he走her，如果有e走er，如果都没有就走r。至于有没有he or e，这个就是各大博客说的fail指针。  
     
 MMP啊！那么多人不会说人话，还不如直接看代码，真是服了。。。     
 
 一个很关键的点，很多人都TM不说！每次更新状态后，还需要通过while进行fail回溯，去回收其他支线上的结果。真的不明白，自己写的博文里面只字不提，这么明显的bug根本没看到么？？走完she了，然后he就错过了，这种明显的问题都瞎么？    
 
 
 
 
 