### 动手原则    
 参考[949]  
   无脑拼接字符串，然后再去判断；而不要先判断了一大堆乱七八糟的东西，然后再去拼接，浪费效率。  
     
   这两者都是一种思想：先做了再说，然后再去判断o不ok。命名为：动手原则。  
   
   适用范围： 需要很麻烦的判断时候。  
     
     
### 反转原则        
  将问题转换成与原问题相反的问题：  
  最常见的就是扎气球的问题，最后用总和做减法。  

### 动态维度数组
  根据参数n，来创建n维的数组。  
  
### 差值法
  场景：求一个数组中的连续子序列，这部分的求和要满足一定的条件：
  比如：是某个数的整数倍；和为某个值；1和0的个数相等。
  
  解法： 将On2转化成On，创建一个map，存储所有[0,i]的和，然后每次[0,j]和[0,i]满足一定条件时([0,j]-[0,i]等于什么什么的时候)，这个时候可以把结果记录。
  
### 先到原则
意思是一行里面有多个时候，就把第一个算进去。常见于矩阵或者数组中，与之相对的是后到原则。     
  
### 二叉树的坐标  
  
 1  
 23  
 4567  
 89101112131415  
   
 会发现，满足条件：  
 parent: val  
 left: val * 2  
 right: val * 2 + 1  
  
### color数组  

  使用一个int[]，用来描述各个位置的状态。常用0表示未访问状态。  
  
    
    
### 悲观处理法  

  详情见802题目。  
  
  类似于标记的湮灭法，只是在这基础上增加了特殊情况下的回溯条件。      
  
### 分治法与逐个法  
  逐个法：是指数组的遍历策略，每次只处理一个。  
  分治法：使用两个数组，每次在[slow,fast]这个区间内进行处理。  

### 全部树Map
  用一个Map存储全部树节点的信息，例如深度，距离某一个节点的距离。
  参见题目863, 865

### 非连续序列统计
  类似[873]，统计符合要求的最长长度的序列有哪些。最大问题在于如何优化O(n^2)。

###  全子数组问题
  类似于898,907，获取全部子区间的某些特征值，可以分为最值，所有可能值，所有值求和
  关键在于要不要用单调栈法。
    
### 跳动窗口  
  类似于滑动窗口，只是ij不是一点点伸缩的，遇到不行的结果，直接i=j  而不是i++。      
### 唯一过程性
  对于某个变量结果，可以代表唯一的过程进度。常见于DP中。  
  首次出现097     
  
### 逆向思维  
改变题目描述的起始和终止点。  
重要：应用场景：因为对未来的迷茫，而无法剪枝的时候。    

### 目标值问题：  
这类问题可以用二分法，先假设目标值，然后判断假设的目标值是不是满足条件中的最小的  
1、Kth问题    
分为两种：    
1、单纯的比大小的第K个位置    
2、经过某些特殊算法得知的位置(例如668)    
  
2、最大值中的最小值问题  
极小化极大问题  
参考778  

### 三分法  
应用题目：把数组分成三份  
如果是任意k份，往往会变成DP，但是如果恰好是三份就有特殊解法。  
可以固定中间的一段，这样子左右两边都变成不用分成多份了  
参见689  

### 值优先遍历(VFS)  
根据数值大小进行遍历  
参见接雨水题目和778  

### 博弈论
题目是两个或多个玩家共同进行，双方在最佳状态下进行。  
题目：913,和各种game  
