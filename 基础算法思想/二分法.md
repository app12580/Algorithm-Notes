### 单个元素
```
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l <= h) {        //循环条件
        int m = l + (h - l) / 2;
        if (nums[m] == key) {
            return m;
        } else if (nums[m] > key) {
            h = m - 1;      //偏移方程
        } else {
            l = m + 1;
        }
    }
    return -1;
}
```
解读：
l==h时候，是能进入方法的。每次由偏移方程进行强制位移。
循环条件内部return，所以条件是l<=h，带了等号，为了防止偏移时使l与h相等，而未进入循环体导致搂过答案。
l=m 可能出现原地踏步的情况。
偏移方程决定了怎么运行，循环条件只是最后的步骤不同，带了等号可能会多运行一次进入循环。
+1和-1只是影响最终结果，只在临近结果的时候才能看出来具体区别。

### 满足条件的最左值
```
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= key) {
            h = m;      //如果nums[m] == key，
        } else {
            l = m + 1;
        }
    }
    return l;
}
```

解读：
关键点1：循环内部没有return，只分成了两个部分。
关键点2：没有return -1的位置。
关键点3：nums[m] == key时候的处理：要么走>的处理方式，要么走<的处理方式
   解释：因为是要求满足条件的最左边的，所以当前的可能不是第一个，那么就相当于>的时候了。
关键点4：h = m;没有-1的原因是这里的条件包含了等于，防止-1而错过答案。
   

### 满足条件的最右值
```
public int binarySearch2(int[] nums, int key) {
        int l = 0, h = nums.length - 1;
        while (l < h) {
            int m = l + (h - l + 1) / 2;        //关键点，在l和m相邻的时候，另m=h
            if (nums[m] > key) {    //因为最右，所以等于时做小于处理
                h = m - 1;  //h移动，l原地踏步
            } else {
                l = m;          
            }
        }
        return h;
    }
```      
      
      
###  小心得   
+1 -1与否，主要是怕重复元素时候，因为和1的偏移而导致错过答案。     
while里面的条件，和while外面的return内容，只需要考虑极值就可以了。     
如果while里面不带等号，则跳出循环时候，二者同一。        
   h = m; 的含义： 如果l和h相邻，此时m=l。   
   l = m + 1;  当l和h相邻，需要此跳出循环。   
      